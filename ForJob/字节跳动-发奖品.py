"""
算法描述：
算法目的在于准备最少的奖品，需要注意的是解决闭环问题，数据结构选择Map
对所有人的分数排序建立索引如
[1,2,3,3]->[1:1,2:2,3:3,3:4]
[1,3,9,4,1]->[1:1,1:5,3:2,4:4,9:3]
先给最小的分数赋值，这里最小的是1，即
[1:1->1,1:5->1,3:2,4:4,9:3]
继续给第二小的3赋值，看3的索引为2，看2-1=1，2+1=3索引下的，1索引有一个，3索引暂时没有，所以3的当前礼物为1+1=2
[1:1->1,1:5->1,3:2->2,4:4,9:3]
以此类推，给4赋值看3和1（长度为5）
[1:1->1,1:5->1,3:2->2,4:4->2,9:3]
..........
[1:1->1,1:5->1,3:2->2,4:4->2,9:3->]
"""

def prepareAward(scores)：
    
    return awardNum

if __name__ == '__main__':
    CaseNum=input("请输入测试样例数目")
    for i in range(CaseNum):
        PNum=input("请输入第"+i+"个测试用例中参加比赛的人数")
        for i in range(PNum):
            scores=input()
            AwardNum=prepareAward(scores)
            print("需要准备"+AwardNum+"个奖品")
    